# See GettingStarted.md for a whole bunch of pointers to understand HTNs, Prolog, etc. This 
# file just describes how to use the framework
from indhtnpy import *
import json
import pprint

# The only class for InductorHtn is called HtnPlanner
# Passing true as the (only) argument turns on debug mode
# Traces of what is happening are sent to the system debug output stream which can be 
# seen on windows with https://docs.microsoft.com/en-us/sysinternals/downloads/debugview
# These traces are much like the standard Prolog traces and will help you understand how 
# the queries and HTN tasks are running and what path they are taking
test = HtnPlanner(False)


# HtnPlanner.HtnCompile()
# Compile a program which includes both HTN and Prolog statements
# The HtnCompile() uses the standard Prolog syntax
# Calling HtnCompile() multiple times will keep adding statements to the database.
# You will get an error if some already exist
prog = """
have-taxi-fare(?distance) :- have-cash(?m), 
							 >=(?m, +(1.5, ?distance)).
walking-distance(?u,?v) :- weather-is(good), 
						   distance(?u,?v,?w), =<(?w, 3).
walking-distance(?u,?v) :- distance(?u,?v,?w), =<(?w, 0.5).


pay-driver(?fare) :- 
	if(have-cash(?m), >=(?m, ?fare)), 
	do(set-cash(?m, -(?m,?fare))).

travel-to(?q) :- 
	if(at(?p), walking-distance(?p, ?q)), 
	do(walk(?p, ?q)).
travel-to(?y) :- 
	if(first(at(?x), at-taxi-stand(?t, ?x), 
		distance(?x, ?y, ?d), have-taxi-fare(?d))), 
	do(hail(?t,?x), ride(?t, ?x, ?y), pay-driver(+(1.50, ?d))).
travel-to(?y) :- 
	if(at(?x), bus-route(?bus, ?x, ?y)), 
	do(wait-for(?bus, ?x), pay-driver(1.00), ride(?bus, ?x, ?y)).

hail(?vehicle, ?location) :- 
	del(), add(at(?vehicle, ?location)).
wait-for(?bus, ?location) :- 
	del(), add(at(?bus, ?location)).
ride(?vehicle, ?a, ?b) :- 
	del(at(?a), at(?vehicle, ?a)), add(at(?b), at(?vehicle, ?b)).
set-cash(?old, ?new) :- 
	del(have-cash(?old)), add(have-cash(?new)).
walk(?here, ?there) :- 
	del(at(?here)), add(at(?there)).

distance(downtown, park, 2).
distance(downtown, uptown, 8).
distance(downtown, suburb, 12).
at-taxi-stand(taxi1, downtown).
at-taxi-stand(taxi2, downtown).
bus-route(bus1, downtown, park).
bus-route(bus2, downtown, uptown).
bus-route(bus3, downtown, suburb).
at(downtown).
weather-is(good).
have-cash(12).
    """
    
# prog = """
# travel-to(Q) :- 
#         if(at(P), walking-distance(P, Q)), 
#         do(walk(P, Q)).
#     walk(Here, There) :- 
#         del(at(Here)), add(at(There)).
#     walking-distance(U,V) :- weather-is(good), 
#                                distance(U,V,W), =<(W, 3).
#     walking-distance(U,V) :- distance(U,V,W), =<(W, 0.5).
#     distance(downtown, park, 2).
#     distance(downtown, uptown, 8).
#     at(downtown).
#     weather-is(good).
#     """
    
result = test.Compile(prog)
if result is not None:
    print("HtnCompile Error:" + result)
    sys.exit()

# HtnPlanner.PrologCompile()
# Compile a standard Prolog program and *add* it to the above, just like HtnCompile() does
# PrologCompile() uses all of the Prolog standard syntax
prog = """
    mortal(X) :- human(X).
    human(socrates).
    """
result = test.Compile(prog)
if result is not None:
    print("PrologCompile Error:" + result)
    sys.exit()

####
# Now the database contains *all* of the facts, rules, and tasks from both programs above!
####

def output(success, result, query, message = "Query"):
    if success is not None:
        print(query + " // " + message + " error: " + success)
        sys.exit()

    solutions = json.loads(result)
    print(f"{message} result for \t{query} :")
    pp = pprint.PrettyPrinter(indent=4)
    pp.pprint(solutions)

# HtnPlanner.FindAllPlans()
# Gets all possible plans that are generated by a query (will return a list of plans, each
# which is a list of terms)
# results are returned in Json format (described farther down)
query = "travel-to(park)."
success, result = test.FindAllPlans(query)
output(success, result, query, "FindAllPlans")

# HtnPlanner.HtnQuery()
# Run a standard Prolog query using the Htn syntax where variables don't have to be
# capitalized, but must have a ? in front
# results are returned in Json format (described farther down)

# HtnPlanner.PrologQuery()
# Run a standard Prolog query
# results are always returned with a ? in front of the name, however
# results are returned in Json format (described farther down)
query = "human(Who)."
success, result = test.PrologQuery(query)
output(success, result, query, "PrologQuery")

query = "at(?where)."
success, result = test.PrologQuery("at(Where).")
output(success, result, query, "PrologQuery")

query = "walking-distance(downtown, park)."
success, result = test.PrologQuery("walking-distance(downtown, park).")
output(success, result, query, "PrologQuery")

# Results are always returned as Json.  
# Terms are just dictionaries with one key, the name of the term, and one value: a list 
# of more terms
# termName(arg1, arg2) => {"termName":[ {"arg1":[]}, {"arg2":[]} ]}

# Here are some examples:
# term that is a constant (aka a term name with no arguments): e.g. tile
term = json.loads("{\"tile\" : [] }")

# term that is a variable always has a ? in front of it: ?tile
term = json.loads("{\"?tile\" : [] }")

# term with arguments: tile(position(1), 1)
term = {"tile" : [{"position" : [1]}, 1]}

# first arg of known term "tile"
print(term["tile"][0])

# There are some helper functions to make accessing things "prettier"
# foo(bar, goo), tile(position(1), 1)
termList = json.loads("[{\"foo\" : [\"bar\", \"goo\"]}, {\"tile\" : [\"firstArg\", \"secondArg\"] }]")

# termName() gives the name of the term
print(termName(termList[0]))

# termArgs() gets the args for a term
print(termArgs(termList[0])[0])

